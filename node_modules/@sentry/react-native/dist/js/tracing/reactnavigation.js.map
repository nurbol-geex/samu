{"version":3,"file":"reactnavigation.js","sourceRoot":"","sources":["../../../src/js/tracing/reactnavigation.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, Integration, Span } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  getActiveSpan,\n  getClient,\n  isPlainObject,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SPAN_STATUS_OK,\n  spanToJSON,\n  startInactiveSpan,\n  timestampInSeconds,\n} from '@sentry/core';\n\nimport type { NewFrameEvent } from '../utils/sentryeventemitter';\nimport type { SentryEventEmitterFallback } from '../utils/sentryeventemitterfallback';\nimport { createSentryFallbackEventEmitter } from '../utils/sentryeventemitterfallback';\nimport { isSentrySpan } from '../utils/span';\nimport { RN_GLOBAL_OBJ } from '../utils/worldwide';\nimport { NATIVE } from '../wrapper';\nimport { ignoreEmptyBackNavigation } from './onSpanEndUtils';\nimport { SPAN_ORIGIN_AUTO_NAVIGATION_REACT_NAVIGATION } from './origin';\nimport type { ReactNativeTracingIntegration } from './reactnativetracing';\nimport { getReactNativeTracingIntegration } from './reactnativetracing';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from './semanticAttributes';\nimport {\n  DEFAULT_NAVIGATION_SPAN_NAME,\n  defaultIdleOptions,\n  getDefaultIdleNavigationSpanOptions,\n  startIdleNavigationSpan as startGenericIdleNavigationSpan,\n} from './span';\nimport { manualInitialDisplaySpans, startTimeToInitialDisplaySpan } from './timetodisplay';\nimport { setSpanDurationAsMeasurementOnSpan } from './utils';\nexport const INTEGRATION_NAME = 'ReactNavigation';\n\nconst NAVIGATION_HISTORY_MAX_SIZE = 200;\n\ninterface ReactNavigationIntegrationOptions {\n  /**\n   * How long the instrumentation will wait for the route to mount after a change has been initiated,\n   * before the transaction is discarded.\n   *\n   * @default 1_000 (ms)\n   */\n  routeChangeTimeoutMs: number;\n\n  /**\n   * Time to initial display measures the time it takes from\n   * navigation dispatch to the render of the first frame of the new screen.\n   *\n   * @default false\n   */\n  enableTimeToInitialDisplay: boolean;\n\n  /**\n   * Does not sample transactions that are from routes that have been seen any more and don't have any spans.\n   * This removes a lot of the clutter as most back navigation transactions are now ignored.\n   *\n   * @default true\n   */\n  ignoreEmptyBackNavigationTransactions: boolean;\n}\n\n/**\n * Instrumentation for React-Navigation V5 and above. See docs or sample app for usage.\n *\n * How this works:\n * - `_onDispatch` is called every time a dispatch happens and sets an IdleTransaction on the scope without any route context.\n * - `_onStateChange` is then called AFTER the state change happens due to a dispatch and sets the route context onto the active transaction.\n * - If `_onStateChange` isn't called within `STATE_CHANGE_TIMEOUT_DURATION` of the dispatch, then the transaction is not sampled and finished.\n */\nexport const reactNavigationIntegration = ({\n  routeChangeTimeoutMs = 1_000,\n  enableTimeToInitialDisplay = false,\n  ignoreEmptyBackNavigationTransactions = true,\n}: Partial<ReactNavigationIntegrationOptions> = {}): Integration & {\n  /**\n   * Pass the ref to the navigation container to register it to the instrumentation\n   * @param navigationContainerRef Ref to a `NavigationContainer`\n   */\n  registerNavigationContainer: (navigationContainerRef: unknown) => void;\n} => {\n  let navigationContainer: NavigationContainer | undefined;\n  let newScreenFrameEventEmitter: SentryEventEmitterFallback | undefined;\n\n  let tracing: ReactNativeTracingIntegration | undefined;\n  let idleSpanOptions: Parameters<typeof startGenericIdleNavigationSpan>[1] = defaultIdleOptions;\n  let latestRoute: NavigationRoute | undefined;\n\n  let latestNavigationSpan: Span | undefined;\n  let navigationProcessingSpan: Span | undefined;\n\n  let initialStateHandled: boolean = false;\n  let stateChangeTimeout: ReturnType<typeof setTimeout> | undefined;\n  let recentRouteKeys: string[] = [];\n\n  if (enableTimeToInitialDisplay) {\n    newScreenFrameEventEmitter = createSentryFallbackEventEmitter();\n    newScreenFrameEventEmitter.initAsync();\n    NATIVE.initNativeReactNavigationNewFrameTracking().catch((reason: unknown) => {\n      logger.error(`${INTEGRATION_NAME} Failed to initialize native new frame tracking: ${reason}`);\n    });\n  }\n\n  /**\n   * Set the initial state and start initial navigation span for the current screen.\n   */\n  const afterAllSetup = (client: Client): void => {\n    tracing = getReactNativeTracingIntegration(client);\n    if (tracing) {\n      idleSpanOptions = {\n        finalTimeout: tracing.options.finalTimeoutMs,\n        idleTimeout: tracing.options.idleTimeoutMs,\n      };\n    }\n\n    if (initialStateHandled) {\n      // We create an initial state here to ensure a transaction gets created before the first route mounts.\n      return undefined;\n    }\n\n    startIdleNavigationSpan();\n\n    if (!navigationContainer) {\n      // This is expected as navigation container is registered after the root component is mounted.\n      return undefined;\n    }\n\n    // Navigation container already registered, just populate with route state\n    updateLatestNavigationSpanWithCurrentRoute();\n    initialStateHandled = true;\n  };\n\n  const registerNavigationContainer = (navigationContainerRef: unknown): void => {\n    /* We prevent duplicate routing instrumentation to be initialized on fast refreshes\n\n      Explanation: If the user triggers a fast refresh on the file that the instrumentation is\n      initialized in, it will initialize a new instance and will cause undefined behavior.\n     */\n    if (RN_GLOBAL_OBJ.__sentry_rn_v5_registered) {\n      logger.log(\n        `${INTEGRATION_NAME} Instrumentation already exists, but register has been called again, doing nothing.`,\n      );\n      return undefined;\n    }\n\n    if (isPlainObject(navigationContainerRef) && 'current' in navigationContainerRef) {\n      navigationContainer = navigationContainerRef.current as NavigationContainer;\n    } else {\n      navigationContainer = navigationContainerRef as NavigationContainer;\n    }\n    if (!navigationContainer) {\n      logger.warn(`${INTEGRATION_NAME} Received invalid navigation container ref!`);\n      return undefined;\n    }\n\n    // This action is emitted on every dispatch\n    navigationContainer.addListener('__unsafe_action__', startIdleNavigationSpan);\n    navigationContainer.addListener('state', updateLatestNavigationSpanWithCurrentRoute);\n    RN_GLOBAL_OBJ.__sentry_rn_v5_registered = true;\n\n    if (initialStateHandled) {\n      return undefined;\n    }\n\n    if (!latestNavigationSpan) {\n      logger.log(`${INTEGRATION_NAME} Navigation container registered, but integration has not been setup yet.`);\n      return undefined;\n    }\n\n    // Navigation Container is registered after the first navigation\n    // Initial navigation span was started, after integration setup,\n    // so now we populate it with the current route.\n    updateLatestNavigationSpanWithCurrentRoute();\n    initialStateHandled = true;\n  };\n\n  /**\n   * To be called on every React-Navigation action dispatch.\n   * It does not name the transaction or populate it with route information. Instead, it waits for the state to fully change\n   * and gets the route information from there, @see updateLatestNavigationSpanWithCurrentRoute\n   */\n  const startIdleNavigationSpan = (): void => {\n    if (latestNavigationSpan) {\n      logger.log(`${INTEGRATION_NAME} A transaction was detected that turned out to be a noop, discarding.`);\n      _discardLatestTransaction();\n      clearStateChangeTimeout();\n    }\n\n    latestNavigationSpan = startGenericIdleNavigationSpan(\n      tracing && tracing.options.beforeStartSpan\n        ? tracing.options.beforeStartSpan(getDefaultIdleNavigationSpanOptions())\n        : getDefaultIdleNavigationSpanOptions(),\n      idleSpanOptions,\n    );\n    latestNavigationSpan?.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SPAN_ORIGIN_AUTO_NAVIGATION_REACT_NAVIGATION);\n    if (ignoreEmptyBackNavigationTransactions) {\n      ignoreEmptyBackNavigation(getClient(), latestNavigationSpan);\n    }\n\n    if (enableTimeToInitialDisplay) {\n      navigationProcessingSpan = startInactiveSpan({\n        op: 'navigation.processing',\n        name: 'Navigation dispatch to navigation cancelled or screen mounted',\n        startTime: latestNavigationSpan && spanToJSON(latestNavigationSpan).start_timestamp,\n      });\n      navigationProcessingSpan.setAttribute(\n        SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n        SPAN_ORIGIN_AUTO_NAVIGATION_REACT_NAVIGATION,\n      );\n    }\n\n    stateChangeTimeout = setTimeout(_discardLatestTransaction, routeChangeTimeoutMs);\n  };\n\n  /**\n   * To be called AFTER the state has been changed to populate the transaction with the current route.\n   */\n  const updateLatestNavigationSpanWithCurrentRoute = (): void => {\n    const stateChangedTimestamp = timestampInSeconds();\n    const previousRoute = latestRoute;\n\n    if (!navigationContainer) {\n      logger.warn(`${INTEGRATION_NAME} Missing navigation container ref. Route transactions will not be sent.`);\n      return undefined;\n    }\n\n    const route = navigationContainer.getCurrentRoute();\n    if (!route) {\n      logger.debug(`[${INTEGRATION_NAME}] Navigation state changed, but no route is rendered.`);\n      return undefined;\n    }\n\n    if (!latestNavigationSpan) {\n      logger.debug(\n        `[${INTEGRATION_NAME}] Navigation state changed, but navigation transaction was not started on dispatch.`,\n      );\n      return undefined;\n    }\n\n    if (previousRoute && previousRoute.key === route.key) {\n      logger.debug(`[${INTEGRATION_NAME}] Navigation state changed, but route is the same as previous.`);\n      pushRecentRouteKey(route.key);\n      latestRoute = route;\n\n      // Clear the latest transaction as it has been handled.\n      latestNavigationSpan = undefined;\n      return undefined;\n    }\n\n    const routeHasBeenSeen = recentRouteKeys.includes(route.key);\n    const latestTtidSpan =\n      !routeHasBeenSeen &&\n      enableTimeToInitialDisplay &&\n      startTimeToInitialDisplaySpan({\n        name: `${route.name} initial display`,\n        isAutoInstrumented: true,\n      });\n\n    const navigationSpanWithTtid = latestNavigationSpan;\n    if (!routeHasBeenSeen && latestTtidSpan) {\n      newScreenFrameEventEmitter?.onceNewFrame(({ newFrameTimestampInSeconds }: NewFrameEvent) => {\n        const activeSpan = getActiveSpan();\n        if (activeSpan && manualInitialDisplaySpans.has(activeSpan)) {\n          logger.warn('[ReactNavigationInstrumentation] Detected manual instrumentation for the current active span.');\n          return;\n        }\n\n        latestTtidSpan.setStatus({ code: SPAN_STATUS_OK });\n        latestTtidSpan.end(newFrameTimestampInSeconds);\n        setSpanDurationAsMeasurementOnSpan('time_to_initial_display', latestTtidSpan, navigationSpanWithTtid);\n      });\n    }\n\n    navigationProcessingSpan?.updateName(`Navigation dispatch to screen ${route.name} mounted`);\n    navigationProcessingSpan?.setStatus({ code: SPAN_STATUS_OK });\n    navigationProcessingSpan?.end(stateChangedTimestamp);\n    navigationProcessingSpan = undefined;\n\n    if (spanToJSON(latestNavigationSpan).description === DEFAULT_NAVIGATION_SPAN_NAME) {\n      latestNavigationSpan.updateName(route.name);\n    }\n    latestNavigationSpan.setAttributes({\n      'route.name': route.name,\n      'route.key': route.key,\n      // TODO: filter PII params instead of dropping them all\n      // 'route.params': {},\n      'route.has_been_seen': routeHasBeenSeen,\n      'previous_route.name': previousRoute?.name,\n      'previous_route.key': previousRoute?.key,\n      // TODO: filter PII params instead of dropping them all\n      // 'previous_route.params': {},\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n    });\n\n    // Clear the timeout so the transaction does not get cancelled.\n    clearStateChangeTimeout();\n\n    addBreadcrumb({\n      category: 'navigation',\n      type: 'navigation',\n      message: `Navigation to ${route.name}`,\n      data: {\n        from: previousRoute?.name,\n        to: route.name,\n      },\n    });\n\n    tracing?.setCurrentRoute(route.name);\n\n    pushRecentRouteKey(route.key);\n    latestRoute = route;\n    // Clear the latest transaction as it has been handled.\n    latestNavigationSpan = undefined;\n  };\n\n  /** Pushes a recent route key, and removes earlier routes when there is greater than the max length */\n  const pushRecentRouteKey = (key: string): void => {\n    recentRouteKeys.push(key);\n\n    if (recentRouteKeys.length > NAVIGATION_HISTORY_MAX_SIZE) {\n      recentRouteKeys = recentRouteKeys.slice(recentRouteKeys.length - NAVIGATION_HISTORY_MAX_SIZE);\n    }\n  };\n\n  /** Cancels the latest transaction so it does not get sent to Sentry. */\n  const _discardLatestTransaction = (): void => {\n    if (latestNavigationSpan) {\n      if (isSentrySpan(latestNavigationSpan)) {\n        latestNavigationSpan['_sampled'] = false;\n      }\n      // TODO: What if it's not SentrySpan?\n      latestNavigationSpan.end();\n      latestNavigationSpan = undefined;\n    }\n    if (navigationProcessingSpan) {\n      navigationProcessingSpan = undefined;\n    }\n  };\n\n  const clearStateChangeTimeout = (): void => {\n    if (typeof stateChangeTimeout !== 'undefined') {\n      clearTimeout(stateChangeTimeout);\n      stateChangeTimeout = undefined;\n    }\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    afterAllSetup,\n    registerNavigationContainer,\n  };\n};\n\nexport interface NavigationRoute {\n  name: string;\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  params?: Record<string, any>;\n}\n\ninterface NavigationContainer {\n  addListener: (type: string, listener: () => void) => void;\n  getCurrentRoute: () => NavigationRoute;\n}\n"]}